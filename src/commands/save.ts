import * as vscode from 'vscode';
import fs from 'fs/promises';


export async function saveBreakPoint() {
    const content = genGDBFileContent();
    const configPath = vscode.workspace.getConfiguration("save-gdb-breakpoints").get<string>("savePath");

    if (!configPath) {
        vscode.window.showErrorMessage("Please set the path in the configuration.");
        return;
    }


    // replace ${workspaceFolder} and other variables
    const path = configPath.replace(/\$\{(.*?)\}/g, (match, variable: string) => {
        switch (variable) {
            case 'workspaceFolder':
            case 'workspaceRoot':
                return vscode.workspace.workspaceFolders?.[0].uri.fsPath || "";
            default:
                return match; // Return the original variable if no replacement is available
        }
    });

    if (!path) {
        vscode.window.showErrorMessage("Please set the path in the configuration.");
        return;
    }

    try {
        // auto create directory
        const dir = path.substring(0, path.lastIndexOf("/"));
        try {
            await fs.access(dir);
        } catch (error) {
            await fs.mkdir(dir, { recursive: true });
        }
        await fs.writeFile(path, content);
    } catch (error) {
        vscode.window.showErrorMessage("Cannot save the file. Please check the path in the configuration.");
        return;
    }
}

export function genGDBFileContent() {
    const breakpoints = vscode.debug.breakpoints;
    let fileContent = "# This file is auto-generated by save-gdb-breakpoints\n";
    fileContent += "# To load this file, run `source <path-to-this-file>` in GDB\n\n";
    for (const breakpoint of breakpoints) {
        let bCmd: string = "";

        const condition = breakpoint.condition;
        const logMessage = breakpoint.logMessage;

        if (breakpoint instanceof vscode.SourceBreakpoint) {
            const path = breakpoint.location.uri.path;
            const line = breakpoint.location.range.start.line;
            bCmd = generateLineBreakpointCommand(path, line + 1, condition, logMessage);
        } else if (breakpoint instanceof vscode.FunctionBreakpoint) {
            bCmd = generateFunctionBreakpointCommand(breakpoint.functionName, condition, logMessage);
        }

        if (!breakpoint.enabled) {
            // add '#' prefix to each line
            bCmd = bCmd.split("\n").map(l => "# " + l).join("\n");
        }

        fileContent += (bCmd + "\n");
    }

    return fileContent;
}

function generateLineBreakpointCommand(path: string, line: number, condition?: string, logMessage?: string): string {
    // TODO: same file name in different folder
    const paths = path.split(/(\\|\/)/)
    path = paths[paths.length - 1];
    return generateGDBCommand(`${path}:${line}`, condition, logMessage);
}

function generateFunctionBreakpointCommand(func: string, condition?: string, logMessage?: string): string {
    return generateGDBCommand(func, condition, logMessage);
}

function escapeQuotes(str: string): string {
    return str.replace(/"/g, '\\"');
}

function generateGDBCommand(pos: string, condition?: string, logMessage?: string): string {

    let command = `break ${pos}`;
    if (condition) {
        command += ` if ${condition}`;
    }

    if (logMessage) {
        let logCommand = "\ncommands\n";
        logCommand += `silent\n`;
        logCommand += `python\n`;
        logCommand += `print("`;

        let last = 0;
        let match: RegExpExecArray | null;
        const re = /\{(.+?)(:(.+?))?\}/g;

        const fmtArgs = [];

        while (match = re.exec(logMessage)) {
            const idx = match.index;
            const fmt = match[3];
            logCommand += escapeQuotes(logMessage.substring(last, idx));
            logCommand += `{}`;

            let arg = `gdb.parse_and_eval('${match[1]}')`;
            if (fmt) {
                arg += `.format_string(format='${fmt}')`;
            }
            fmtArgs.push(arg);
            last = idx + match[0].length;
        }
        logCommand += escapeQuotes(logMessage.substring(last));
        logCommand += `".format(${fmtArgs.join(", ")})`;
        logCommand += `)\n`;
        logCommand += `end\n`;
        logCommand += `continue\n`;
        logCommand += `end\n`;
        logCommand += `# end of breakpoint: ${pos}`
        command += logCommand;
    }

    return command;
}
